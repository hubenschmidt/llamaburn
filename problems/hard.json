{
  "name": "Hard Algorithm Problems",
  "problems": [
    {
      "id": "median-sorted-arrays",
      "title": "Median of Two Sorted Arrays",
      "difficulty": "hard",
      "description": "Given two sorted arrays nums1 and nums2, return the median of the two sorted arrays. The overall runtime complexity should be O(log(m+n)).",
      "time_limit_ms": 5000,
      "signatures": {
        "python": "def find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float:",
        "javascript": "function findMedianSortedArrays(nums1, nums2)"
      },
      "test_cases": [
        { "input": "[[1,3], [2]]", "expected": "2.0" },
        { "input": "[[1,2], [3,4]]", "expected": "2.5" },
        { "input": "[[0,0], [0,0]]", "expected": "0.0" },
        { "input": "[[], [1]]", "expected": "1.0" }
      ]
    },
    {
      "id": "trapping-rain-water",
      "title": "Trapping Rain Water",
      "difficulty": "hard",
      "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
      "time_limit_ms": 5000,
      "signatures": {
        "python": "def trap(height: list[int]) -> int:",
        "javascript": "function trap(height)"
      },
      "test_cases": [
        { "input": "[[0,1,0,2,1,0,1,3,2,1,2,1]]", "expected": "6" },
        { "input": "[[4,2,0,3,2,5]]", "expected": "9" },
        { "input": "[[1,2,3,4,5]]", "expected": "0" },
        { "input": "[[5,4,3,2,1]]", "expected": "0" }
      ]
    },
    {
      "id": "n-queens",
      "title": "N-Queens",
      "difficulty": "hard",
      "description": "Place n queens on an n x n chessboard such that no two queens attack each other. Return the number of distinct solutions.",
      "time_limit_ms": 10000,
      "signatures": {
        "python": "def total_n_queens(n: int) -> int:",
        "javascript": "function totalNQueens(n)"
      },
      "test_cases": [
        { "input": "[4]", "expected": "2" },
        { "input": "[1]", "expected": "1" },
        { "input": "[8]", "expected": "92" },
        { "input": "[5]", "expected": "10" }
      ]
    },
    {
      "id": "longest-valid-parens",
      "title": "Longest Valid Parentheses",
      "difficulty": "hard",
      "description": "Given a string containing just '(' and ')', return the length of the longest valid (well-formed) parentheses substring.",
      "time_limit_ms": 5000,
      "signatures": {
        "python": "def longest_valid_parentheses(s: str) -> int:",
        "javascript": "function longestValidParentheses(s)"
      },
      "test_cases": [
        { "input": "[\"(()\"]", "expected": "2" },
        { "input": "[\")()())\"]", "expected": "4" },
        { "input": "[\"\"]", "expected": "0" },
        { "input": "[\"()(())\"]", "expected": "6" }
      ]
    },
    {
      "id": "min-window-substring",
      "title": "Minimum Window Substring",
      "difficulty": "hard",
      "description": "Given strings s and t, return the minimum window substring of s that contains all characters of t. Return empty string if no such window exists.",
      "time_limit_ms": 5000,
      "signatures": {
        "python": "def min_window(s: str, t: str) -> str:",
        "javascript": "function minWindow(s, t)"
      },
      "test_cases": [
        { "input": "[\"ADOBECODEBANC\", \"ABC\"]", "expected": "\"BANC\"" },
        { "input": "[\"a\", \"a\"]", "expected": "\"a\"" },
        { "input": "[\"a\", \"aa\"]", "expected": "\"\"" },
        { "input": "[\"cabwefgewcwaefgcf\", \"cae\"]", "expected": "\"cwae\"" }
      ]
    },
    {
      "id": "largest-rectangle-histogram",
      "title": "Largest Rectangle in Histogram",
      "difficulty": "hard",
      "description": "Given an array of integers heights representing the histogram's bar heights where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
      "time_limit_ms": 5000,
      "signatures": {
        "python": "def largest_rectangle_area(heights: list[int]) -> int:",
        "javascript": "function largestRectangleArea(heights)"
      },
      "test_cases": [
        { "input": "[[2,1,5,6,2,3]]", "expected": "10" },
        { "input": "[[2,4]]", "expected": "4" },
        { "input": "[[1]]", "expected": "1" },
        { "input": "[[2,1,2]]", "expected": "3" }
      ]
    },
    {
      "id": "edit-distance",
      "title": "Edit Distance",
      "difficulty": "hard",
      "description": "Given two strings word1 and word2, return the minimum number of operations (insert, delete, replace) required to convert word1 to word2.",
      "time_limit_ms": 5000,
      "signatures": {
        "python": "def min_distance(word1: str, word2: str) -> int:",
        "javascript": "function minDistance(word1, word2)"
      },
      "test_cases": [
        { "input": "[\"horse\", \"ros\"]", "expected": "3" },
        { "input": "[\"intention\", \"execution\"]", "expected": "5" },
        { "input": "[\"\", \"a\"]", "expected": "1" },
        { "input": "[\"abc\", \"abc\"]", "expected": "0" }
      ]
    },
    {
      "id": "word-ladder",
      "title": "Word Ladder",
      "difficulty": "hard",
      "description": "Given begin and end words and a dictionary, return the length of the shortest transformation sequence from begin to end, changing one letter at a time. Return 0 if no sequence exists.",
      "time_limit_ms": 10000,
      "signatures": {
        "python": "def ladder_length(begin_word: str, end_word: str, word_list: list[str]) -> int:",
        "javascript": "function ladderLength(beginWord, endWord, wordList)"
      },
      "test_cases": [
        { "input": "[\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]]", "expected": "5" },
        { "input": "[\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]]", "expected": "0" },
        { "input": "[\"a\", \"c\", [\"a\",\"b\",\"c\"]]", "expected": "2" }
      ]
    },
    {
      "id": "merge-k-sorted",
      "title": "Merge K Sorted Lists",
      "difficulty": "hard",
      "description": "Given k sorted arrays, merge them into one sorted array.",
      "time_limit_ms": 5000,
      "signatures": {
        "python": "def merge_k_sorted(lists: list[list[int]]) -> list[int]:",
        "javascript": "function mergeKSorted(lists)"
      },
      "test_cases": [
        { "input": "[[[1,4,5],[1,3,4],[2,6]]]", "expected": "[1,1,2,3,4,4,5,6]" },
        { "input": "[[]]", "expected": "[]" },
        { "input": "[[[]]]", "expected": "[]" },
        { "input": "[[[1],[2],[3]]]", "expected": "[1,2,3]" }
      ]
    },
    {
      "id": "max-path-sum",
      "title": "Binary Tree Maximum Path Sum",
      "difficulty": "hard",
      "description": "Given the root of a binary tree as a nested array [val, left, right], return the maximum path sum. A path is any sequence of nodes connected by edges.",
      "time_limit_ms": 5000,
      "signatures": {
        "python": "def max_path_sum(root: list) -> int:",
        "javascript": "function maxPathSum(root)"
      },
      "test_cases": [
        { "input": "[[1,[2,null,null],[3,null,null]]]", "expected": "6" },
        { "input": "[[-10,[9,null,null],[20,[15,null,null],[7,null,null]]]]", "expected": "42" },
        { "input": "[[-3,null,null]]", "expected": "-3" }
      ]
    },
    {
      "id": "regex-matching",
      "title": "Regular Expression Matching",
      "difficulty": "hard",
      "description": "Implement regular expression matching with support for '.' (matches any single character) and '*' (matches zero or more of the preceding element).",
      "time_limit_ms": 5000,
      "signatures": {
        "python": "def is_match(s: str, p: str) -> bool:",
        "javascript": "function isMatch(s, p)"
      },
      "test_cases": [
        { "input": "[\"aa\", \"a\"]", "expected": "false" },
        { "input": "[\"aa\", \"a*\"]", "expected": "true" },
        { "input": "[\"ab\", \".*\"]", "expected": "true" },
        { "input": "[\"aab\", \"c*a*b\"]", "expected": "true" },
        { "input": "[\"mississippi\", \"mis*is*p*.\"]", "expected": "false" }
      ]
    },
    {
      "id": "serialize-tree",
      "title": "Serialize and Deserialize Binary Tree",
      "difficulty": "hard",
      "description": "Design an algorithm to serialize a binary tree to a string and deserialize it back. Input/output is a nested array [val, left, right] where null represents empty nodes.",
      "time_limit_ms": 5000,
      "signatures": {
        "python": "def codec_roundtrip(root: list) -> list:",
        "javascript": "function codecRoundtrip(root)"
      },
      "test_cases": [
        { "input": "[[1,[2,null,null],[3,[4,null,null],[5,null,null]]]]", "expected": "[1,[2,null,null],[3,[4,null,null],[5,null,null]]]" },
        { "input": "[null]", "expected": "null" },
        { "input": "[[1,null,null]]", "expected": "[1,null,null]" }
      ]
    }
  ]
}
